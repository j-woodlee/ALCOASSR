{"version":3,"sources":["../../../lib/utils/stream-buf.js"],"names":["Stream","require","PromiseLib","utils","StringBuf","StringChunk","data","encoding","_data","_encoding","prototype","length","toBuffer","copy","target","targetOffset","offset","_buffer","Buffer","StringBufChunk","_buf","BufferChunk","ReadWriteBuf","size","buffer","iRead","iWrite","buf","eod","full","read","undefined","write","chunk","Math","min","StreamBuf","module","exports","options","bufSize","buffers","batch","corked","inPos","outPos","pipes","paused","inherits","Duplex","concat","map","rwBuf","_getWritableBuffer","last","push","_pipe","pipe","Promise","resolve","promises","all","then","nop","_writeToBuffers","inLen","callback","Function","shift","process","nextTick","emit","cork","_flush","uncork","end","writeComplete","error","forEach","first","filter","Boolean","setEncoding","pause","resume","isPaused","destination","unpipe","unshift","Error","wrap"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Stream = require('stream');\nconst PromiseLib = require('./promise');\n\nconst utils = require('./utils');\nconst StringBuf = require('./string-buf');\n\n// =============================================================================\n// data chunks - encapsulating incoming data\nconst StringChunk = function(data, encoding) {\n  this._data = data;\n  this._encoding = encoding;\n};\nStringChunk.prototype = {\n  get length() {\n    return this.toBuffer().length;\n  },\n  // copy to target buffer\n  copy(target, targetOffset, offset, length) {\n    return this.toBuffer().copy(target, targetOffset, offset, length);\n  },\n  toBuffer() {\n    if (!this._buffer) {\n      this._buffer = new Buffer(this._data, this._encoding);\n    }\n    return this._buffer;\n  },\n};\nconst StringBufChunk = function(data) {\n  this._data = data;\n};\nStringBufChunk.prototype = {\n  get length() {\n    return this._data.length;\n  },\n  // copy to target buffer\n  copy(target, targetOffset, offset, length) {\n    // eslint-disable-next-line no-underscore-dangle\n    return this._data._buf.copy(target, targetOffset, offset, length);\n  },\n  toBuffer() {\n    return this._data.toBuffer();\n  },\n};\nconst BufferChunk = function(data) {\n  this._data = data;\n};\nBufferChunk.prototype = {\n  get length() {\n    return this._data.length;\n  },\n  // copy to target buffer\n  copy(target, targetOffset, offset, length) {\n    this._data.copy(target, targetOffset, offset, length);\n  },\n  toBuffer() {\n    return this._data;\n  },\n};\n\n// =============================================================================\n// ReadWriteBuf - a single buffer supporting simple read-write\nconst ReadWriteBuf = function(size) {\n  this.size = size;\n  // the buffer\n  this.buffer = new Buffer(size);\n  // read index\n  this.iRead = 0;\n  // write index\n  this.iWrite = 0;\n};\nReadWriteBuf.prototype = {\n  toBuffer() {\n    if (this.iRead === 0 && this.iWrite === this.size) {\n      return this.buffer;\n    }\n\n    const buf = new Buffer(this.iWrite - this.iRead);\n    this.buffer.copy(buf, 0, this.iRead, this.iWrite);\n    return buf;\n  },\n  get length() {\n    return this.iWrite - this.iRead;\n  },\n  get eod() {\n    return this.iRead === this.iWrite;\n  },\n  get full() {\n    return this.iWrite === this.size;\n  },\n  read(size) {\n    let buf;\n    // read size bytes from buffer and return buffer\n    if (size === 0) {\n      // special case - return null if no data requested\n      return null;\n    }\n\n    if (size === undefined || size >= this.length) {\n      // if no size specified or size is at least what we have then return all of the bytes\n      buf = this.toBuffer();\n      this.iRead = this.iWrite;\n      return buf;\n    }\n\n    // otherwise return a chunk\n    buf = new Buffer(size);\n    this.buffer.copy(buf, 0, this.iRead, size);\n    this.iRead += size;\n    return buf;\n  },\n  write(chunk, offset, length) {\n    // write as many bytes from data from optional source offset\n    // and return number of bytes written\n    const size = Math.min(length, this.size - this.iWrite);\n    chunk.copy(this.buffer, this.iWrite, offset, offset + size);\n    this.iWrite += size;\n    return size;\n  },\n};\n\n// =============================================================================\n// StreamBuf - a multi-purpose read-write stream\n//  As MemBuf - write as much data as you like. Then call toBuffer() to consolidate\n//  As StreamHub - pipe to multiple writables\n//  As readable stream - feed data into the writable part and have some other code read from it.\nconst StreamBuf = (module.exports = function(options) {\n  options = options || {};\n  this.bufSize = options.bufSize || 1024 * 1024;\n  this.buffers = [];\n\n  // batch mode fills a buffer completely before passing the data on\n  // to pipes or 'readable' event listeners\n  this.batch = options.batch || false;\n\n  this.corked = false;\n  // where in the current writable buffer we're up to\n  this.inPos = 0;\n\n  // where in the current readable buffer we've read up to\n  this.outPos = 0;\n\n  // consuming pipe streams go here\n  this.pipes = [];\n\n  // controls emit('data')\n  this.paused = false;\n\n  this.encoding = null;\n});\n\nutils.inherits(StreamBuf, Stream.Duplex, {\n  toBuffer() {\n    switch (this.buffers.length) {\n      case 0:\n        return null;\n      case 1:\n        return this.buffers[0].toBuffer();\n      default:\n        return Buffer.concat(this.buffers.map(rwBuf => rwBuf.toBuffer()));\n    }\n  },\n\n  // writable\n  // event drain - if write returns false (which it won't), indicates when safe to write again.\n  // finish - end() has been called\n  // pipe(src) - pipe() has been called on readable\n  // unpipe(src) - unpipe() has been called on readable\n  // error - duh\n\n  _getWritableBuffer() {\n    if (this.buffers.length) {\n      const last = this.buffers[this.buffers.length - 1];\n      if (!last.full) {\n        return last;\n      }\n    }\n    const buf = new ReadWriteBuf(this.bufSize);\n    this.buffers.push(buf);\n    return buf;\n  },\n\n  _pipe(chunk) {\n    const write = function(pipe) {\n      return new PromiseLib.Promise(resolve => {\n        pipe.write(chunk.toBuffer(), () => {\n          resolve();\n        });\n      });\n    };\n    const promises = this.pipes.map(write);\n    return promises.length ? PromiseLib.Promise.all(promises).then(utils.nop) : PromiseLib.Promise.resolve();\n  },\n  _writeToBuffers(chunk) {\n    let inPos = 0;\n    const inLen = chunk.length;\n    while (inPos < inLen) {\n      // find writable buffer\n      const buffer = this._getWritableBuffer();\n\n      // write some data\n      inPos += buffer.write(chunk, inPos, inLen - inPos);\n    }\n  },\n  write(data, encoding, callback) {\n    if (encoding instanceof Function) {\n      callback = encoding;\n      encoding = 'utf8';\n    }\n    callback = callback || utils.nop;\n\n    // encapsulate data into a chunk\n    let chunk;\n    if (data instanceof StringBuf) {\n      chunk = new StringBufChunk(data);\n    } else if (data instanceof Buffer) {\n      chunk = new BufferChunk(data);\n    } else {\n      // assume string\n      chunk = new StringChunk(data, encoding);\n    }\n\n    // now, do something with the chunk\n    if (this.pipes.length) {\n      if (this.batch) {\n        this._writeToBuffers(chunk);\n        while (!this.corked && this.buffers.length > 1) {\n          this._pipe(this.buffers.shift());\n        }\n      } else if (!this.corked) {\n        this._pipe(chunk).then(callback);\n      } else {\n        this._writeToBuffers(chunk);\n        process.nextTick(callback);\n      }\n    } else {\n      if (!this.paused) {\n        this.emit('data', chunk.toBuffer());\n      }\n\n      this._writeToBuffers(chunk);\n      this.emit('readable');\n    }\n\n    return true;\n  },\n  cork() {\n    this.corked = true;\n  },\n  _flush(/* destination */) {\n    // if we have comsumers...\n    if (this.pipes.length) {\n      // and there's stuff not written\n      while (this.buffers.length) {\n        this._pipe(this.buffers.shift());\n      }\n    }\n  },\n  uncork() {\n    this.corked = false;\n    this._flush();\n  },\n  end(chunk, encoding, callback) {\n    const writeComplete = error => {\n      if (error) {\n        callback(error);\n      } else {\n        this._flush();\n        this.pipes.forEach(pipe => {\n          pipe.end();\n        });\n        this.emit('finish');\n      }\n    };\n    if (chunk) {\n      this.write(chunk, encoding, writeComplete);\n    } else {\n      writeComplete();\n    }\n  },\n\n  // readable\n  // event readable - some data is now available\n  // event data - switch to flowing mode - feeds chunks to handler\n  // event end - no more data\n  // event close - optional, indicates upstream close\n  // event error - duh\n  read(size) {\n    let buffers;\n    // read min(buffer, size || infinity)\n    if (size) {\n      buffers = [];\n      while (size && this.buffers.length && !this.buffers[0].eod) {\n        const first = this.buffers[0];\n        const buffer = first.read(size);\n        size -= buffer.length;\n        buffers.push(buffer);\n        if (first.eod && first.full) {\n          this.buffers.shift();\n        }\n      }\n      return Buffer.concat(buffers);\n    }\n\n    buffers = this.buffers.map(buf => buf.toBuffer()).filter(Boolean);\n    this.buffers = [];\n    return Buffer.concat(buffers);\n  },\n  setEncoding(encoding) {\n    // causes stream.read or stream.on('data) to return strings of encoding instead of Buffer objects\n    this.encoding = encoding;\n  },\n  pause() {\n    this.paused = true;\n  },\n  resume() {\n    this.paused = false;\n  },\n  isPaused() {\n    return !!this.paused;\n  },\n  pipe(destination) {\n    // add destination to pipe list & write current buffer\n    this.pipes.push(destination);\n    if (!this.paused && this.buffers.length) {\n      this.end();\n    }\n  },\n  unpipe(destination) {\n    // remove destination from pipe list\n    this.pipes = this.pipes.filter(pipe => pipe !== destination);\n  },\n  unshift(/* chunk */) {\n    // some numpty has read some data that's not for them and they want to put it back!\n    // Might implement this some day\n    throw new Error('Not Implemented');\n  },\n  wrap(/* stream */) {\n    // not implemented\n    throw new Error('Not Implemented');\n  },\n});\n"],"file":"stream-buf.js"}