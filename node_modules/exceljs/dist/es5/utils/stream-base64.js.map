{"version":3,"sources":["../../../lib/utils/stream-base64.js"],"names":["Stream","require","utils","StreamBuf","module","exports","pipes","inherits","Duplex","write","cork","uncork","end","read","setEncoding","encoding","pause","resume","isPaused","pipe","destination","push","unpipe","filter","unshift","Error","wrap"],"mappings":"AAAA;;AAEA,IAAMA,MAAM,GAAGC,OAAO,CAAC,QAAD,CAAtB;;AACA,IAAMC,KAAK,GAAGD,OAAO,CAAC,SAAD,CAArB,C,CAEA;AACA;AACA;;;AACA,IAAME,SAAS,GAAIC,MAAM,CAACC,OAAP,GAAiB,YAAW;AAC7C;AACA,OAAKC,KAAL,GAAa,EAAb;AACD,CAHD;;AAKAJ,KAAK,CAACK,QAAN,CAAeJ,SAAf,EAA0BH,MAAM,CAACQ,MAAjC,EAAyC;AACvC;AACA;AACA;AACA;AACA;AACA;AAEAC,EAAAA,KARuC;AAQjC;AAAsB;AAC1B,WAAO,IAAP;AACD,GAVsC;AAWvCC,EAAAA,IAXuC,kBAWhC,CAAE,CAX8B;AAYvCC,EAAAA,MAZuC,oBAY9B,CAAE,CAZ4B;AAavCC,EAAAA,GAbuC;AAanC;AAAiC,GAAE,CAbA;AAevC;AACA;AACA;AACA;AACA;AACA;AACAC,EAAAA,IArBuC;AAqBlC;AAAY,GAAE,CArBoB;AAsBvCC,EAAAA,WAtBuC,uBAsB3BC,QAtB2B,EAsBjB;AACpB;AACA,SAAKA,QAAL,GAAgBA,QAAhB;AACD,GAzBsC;AA0BvCC,EAAAA,KA1BuC,mBA0B/B,CAAE,CA1B6B;AA2BvCC,EAAAA,MA3BuC,oBA2B9B,CAAE,CA3B4B;AA4BvCC,EAAAA,QA5BuC,sBA4B5B,CAAE,CA5B0B;AA6BvCC,EAAAA,IA7BuC,gBA6BlCC,WA7BkC,EA6BrB;AAChB;AACA,SAAKd,KAAL,CAAWe,IAAX,CAAgBD,WAAhB;AACD,GAhCsC;AAiCvCE,EAAAA,MAjCuC,kBAiChCF,WAjCgC,EAiCnB;AAClB;AACA,SAAKd,KAAL,GAAa,KAAKA,KAAL,CAAWiB,MAAX,CAAkB,UAAAJ,IAAI;AAAA,aAAIA,IAAI,KAAKC,WAAb;AAAA,KAAtB,CAAb;AACD,GApCsC;AAqCvCI,EAAAA,OArCuC;AAqC/B;AAAa;AACnB;AACA;AACA,UAAM,IAAIC,KAAJ,CAAU,iBAAV,CAAN;AACD,GAzCsC;AA0CvCC,EAAAA,IA1CuC;AA0ClC;AAAc;AACjB;AACA,UAAM,IAAID,KAAJ,CAAU,iBAAV,CAAN;AACD;AA7CsC,CAAzC","sourcesContent":["'use strict';\n\nconst Stream = require('stream');\nconst utils = require('./utils');\n\n// =============================================================================\n// StreamBase64 - A utility to convert to/from base64 stream\n// Note: does not buffer data, must be piped\nconst StreamBuf = (module.exports = function() {\n  // consuming pipe streams go here\n  this.pipes = [];\n});\n\nutils.inherits(StreamBuf, Stream.Duplex, {\n  // writable\n  // event drain - if write returns false (which it won't), indicates when safe to write again.\n  // finish - end() has been called\n  // pipe(src) - pipe() has been called on readable\n  // unpipe(src) - unpipe() has been called on readable\n  // error - duh\n\n  write(/* data, encoding */) {\n    return true;\n  },\n  cork() {},\n  uncork() {},\n  end(/* chunk, encoding, callback */) {},\n\n  // readable\n  // event readable - some data is now available\n  // event data - switch to flowing mode - feeds chunks to handler\n  // event end - no more data\n  // event close - optional, indicates upstream close\n  // event error - duh\n  read(/* size */) {},\n  setEncoding(encoding) {\n    // causes stream.read or stream.on('data) to return strings of encoding instead of Buffer objects\n    this.encoding = encoding;\n  },\n  pause() {},\n  resume() {},\n  isPaused() {},\n  pipe(destination) {\n    // add destination to pipe list & write current buffer\n    this.pipes.push(destination);\n  },\n  unpipe(destination) {\n    // remove destination from pipe list\n    this.pipes = this.pipes.filter(pipe => pipe !== destination);\n  },\n  unshift(/* chunk */) {\n    // some numpty has read some data that's not for them and they want to put it back!\n    // Might implement this some day\n    throw new Error('Not Implemented');\n  },\n  wrap(/* stream */) {\n    // not implemented\n    throw new Error('Not Implemented');\n  },\n});\n"],"file":"stream-base64.js"}