{"version":3,"sources":["../../../../../lib/xlsx/xform/sheet/merges.js"],"names":["_","require","Range","colCache","Enums","Merges","module","exports","merges","prototype","add","merge","master","expandToAddress","address","range","mergeCells","map","reconcile","rows","each","dimensions","decode","i","top","bottom","row","j","left","right","cell","cells","type","ValueType","Null","encodeAddress","Merge","tl","getMasterAddress","hash"],"mappings":"AAAA;;AAEA,IAAMA,CAAC,GAAGC,OAAO,CAAC,2BAAD,CAAjB;;AAEA,IAAMC,KAAK,GAAGD,OAAO,CAAC,oBAAD,CAArB;;AACA,IAAME,QAAQ,GAAGF,OAAO,CAAC,0BAAD,CAAxB;;AACA,IAAMG,KAAK,GAAGH,OAAO,CAAC,oBAAD,CAArB;;AAEA,IAAMI,MAAM,GAAIC,MAAM,CAACC,OAAP,GAAiB,YAAW;AAC1C;AACA,OAAKC,MAAL,GAAc,EAAd;AACD,CAHD;;AAKAH,MAAM,CAACI,SAAP,GAAmB;AACjBC,EAAAA,GADiB,eACbC,KADa,EACN;AACT;AACA,QAAI,KAAKH,MAAL,CAAYG,KAAK,CAACC,MAAlB,CAAJ,EAA+B;AAC7B,WAAKJ,MAAL,CAAYG,KAAK,CAACC,MAAlB,EAA0BC,eAA1B,CAA0CF,KAAK,CAACG,OAAhD;AACD,KAFD,MAEO;AACL,UAAMC,KAAK,aAAMJ,KAAK,CAACC,MAAZ,cAAsBD,KAAK,CAACG,OAA5B,CAAX;AACA,WAAKN,MAAL,CAAYG,KAAK,CAACC,MAAlB,IAA4B,IAAIV,KAAJ,CAAUa,KAAV,CAA5B;AACD;AACF,GATgB;;AAUjB,MAAIC,UAAJ,GAAiB;AACf,WAAOhB,CAAC,CAACiB,GAAF,CAAM,KAAKT,MAAX,EAAmB,UAAAG,KAAK;AAAA,aAAIA,KAAK,CAACI,KAAV;AAAA,KAAxB,CAAP;AACD,GAZgB;;AAajBG,EAAAA,SAbiB,qBAaPF,UAbO,EAaKG,IAbL,EAaW;AAC1B;AACAnB,IAAAA,CAAC,CAACoB,IAAF,CAAOJ,UAAP,EAAmB,UAAAL,KAAK,EAAI;AAC1B,UAAMU,UAAU,GAAGlB,QAAQ,CAACmB,MAAT,CAAgBX,KAAhB,CAAnB;;AACA,WAAK,IAAIY,CAAC,GAAGF,UAAU,CAACG,GAAxB,EAA6BD,CAAC,IAAIF,UAAU,CAACI,MAA7C,EAAqDF,CAAC,EAAtD,EAA0D;AACxD,YAAMG,GAAG,GAAGP,IAAI,CAACI,CAAC,GAAG,CAAL,CAAhB;;AACA,aAAK,IAAII,CAAC,GAAGN,UAAU,CAACO,IAAxB,EAA8BD,CAAC,IAAIN,UAAU,CAACQ,KAA9C,EAAqDF,CAAC,EAAtD,EAA0D;AACxD,cAAMG,IAAI,GAAGJ,GAAG,CAACK,KAAJ,CAAUJ,CAAC,GAAG,CAAd,CAAb;;AACA,cAAI,CAACG,IAAL,EAAW;AACT;AACAJ,YAAAA,GAAG,CAACK,KAAJ,CAAUJ,CAAV,IAAe;AACbK,cAAAA,IAAI,EAAE5B,KAAK,CAAC6B,SAAN,CAAgBC,IADT;AAEbpB,cAAAA,OAAO,EAAEX,QAAQ,CAACgC,aAAT,CAAuBZ,CAAvB,EAA0BI,CAA1B;AAFI,aAAf;AAID,WAND,MAMO,IAAIG,IAAI,CAACE,IAAL,KAAc5B,KAAK,CAAC6B,SAAN,CAAgBG,KAAlC,EAAyC;AAC9CN,YAAAA,IAAI,CAAClB,MAAL,GAAcS,UAAU,CAACgB,EAAzB;AACD;AACF;AACF;AACF,KAjBD;AAkBD,GAjCgB;AAkCjBC,EAAAA,gBAlCiB,4BAkCAxB,OAlCA,EAkCS;AACxB;AACA,QAAMC,KAAK,GAAG,KAAKwB,IAAL,CAAUzB,OAAV,CAAd;AACA,WAAOC,KAAK,IAAIA,KAAK,CAACsB,EAAtB;AACD;AAtCgB,CAAnB","sourcesContent":["'use strict';\n\nconst _ = require('../../../utils/under-dash');\n\nconst Range = require('../../../doc/range');\nconst colCache = require('../../../utils/col-cache');\nconst Enums = require('../../../doc/enums');\n\nconst Merges = (module.exports = function() {\n  // optional mergeCells is array of ranges (like the xml)\n  this.merges = {};\n});\n\nMerges.prototype = {\n  add(merge) {\n    // merge is {address, master}\n    if (this.merges[merge.master]) {\n      this.merges[merge.master].expandToAddress(merge.address);\n    } else {\n      const range = `${merge.master}:${merge.address}`;\n      this.merges[merge.master] = new Range(range);\n    }\n  },\n  get mergeCells() {\n    return _.map(this.merges, merge => merge.range);\n  },\n  reconcile(mergeCells, rows) {\n    // reconcile merge list with merge cells\n    _.each(mergeCells, merge => {\n      const dimensions = colCache.decode(merge);\n      for (let i = dimensions.top; i <= dimensions.bottom; i++) {\n        const row = rows[i - 1];\n        for (let j = dimensions.left; j <= dimensions.right; j++) {\n          const cell = row.cells[j - 1];\n          if (!cell) {\n            // nulls are not included in document - so if master cell has no value - add a null one here\n            row.cells[j] = {\n              type: Enums.ValueType.Null,\n              address: colCache.encodeAddress(i, j),\n            };\n          } else if (cell.type === Enums.ValueType.Merge) {\n            cell.master = dimensions.tl;\n          }\n        }\n      }\n    });\n  },\n  getMasterAddress(address) {\n    // if address has been merged, return its master's address. Assumes reconcile has been called\n    const range = this.hash[address];\n    return range && range.tl;\n  },\n};\n"],"file":"merges.js"}